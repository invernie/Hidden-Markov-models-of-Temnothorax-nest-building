---
title: "Evaluating alternative models"
author: "Edith Invernizzi"
date: "18/11/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

setwd("Path/To/Folder")

source("Path/To/Folder/HMM_functions_for_model_fitting.R")

source("Path/To/Folder/Global decoding using Viterbi algorithm.R")

source("Path/To/Folder/Simulated samples.R")

library(MASS)
library(ggplot2)
library(ggpubr)

```

This document was created for the visualisation and comparison of GLMs (HMMs) applied to _Temnothorax rugatulus_ nest wall building.

We are interested in the covaratiates influencing deposition rate at building sites. Rates and stone density are measured locally at each building site. We assume the dependent variable to be gamma-distributed, with colony-specific variance. We model the mean of the gamma distribution using a GLM approach with log-link function.
We assume the coefficients of the covariates to be constant both across colonies and across sites, while the intercept varies between colonies.

We compare six models generating the predicted mean value from covariates:   
1.  stone density   
2.  stone_dens + dist    
3.  stone_dens + stone_dens^2    
4.  stone_dens + stone_dens^2 + dist

```{r data, echo=F, warning=FALSE, message=FALSE}
## Data used for fitting the models (for visualisation)
d1         <- read.csv("Path/To/Folder/Processed data/rates_by_ROI_NAs.csv", header = TRUE)
# ADD Site variable
d1$Site    <- substr(d1$ID,5,5)
d1$stone_dens2 <- (d1$stone_dens)^2

# Change zeros to small values (not to use zero inflation in the model):
# Note that this correction is biologically justified as ant workers are believed to never completely cessate their building activity, instead maintaining a baseline low activity rate.
data2 <- d1
data2[which(data2[,"D"]==0), "D"] <- 0.001

datalist0      <- list()
datalist0[[1]] <- data2[which(data2$colony=="R05"),]
datalist0[[2]] <- data2[which(data2$colony=="R29"),]
datalist0[[3]] <- data2[which(data2$colony=="R34"),]
datalist0[[4]] <- data2[which(data2$colony=="R54"),]

```

### AIC comparison

We start by comparing the best fits of all models using AIC (shown in order).

```{r AIC, echo=FALSE, warning=FALSE, message=FALSE}

load("Path/To/Folder/Results/Results4Models100Fits.RData")
## AIC weighing

# Model order in matrix: 
# [1] stone_dens; 
# [2] stone_dens + dist; 
# [3] stone_dens + stone_dens^2; 
# [4] stone_dens + stone_dens^2 + dist.

# At the moment the best model is the one with stone density as a quadratic function, which is the third fit
m1 <- best_fit_list[[1]]
m2 <- best_fit_list[[2]]
m3 <- best_fit_list[[3]]
m4 <- best_fit_list[[4]]
c(m1$AIC, m2$AIC, m3$AIC, m4$AIC)

```

The model with the quadratic term for stone density and with distance scores best. Let's take a look at it.


## BEST MODEL

A summary of the model fit is found below. The parameters are:  

* `int` : intercept (row: colony-; and column: state-specific)   
* `colL` : covariate coefficient (state-specific, identical across colonies)   
* `gsd` : standard deviation of the gamma distribution (colony- and state-specific)   
* `delta` : state starting probability (identical across colonies)   
* `gamma` : transition probability matrix (identical across colonies)   
* `mllk` : value of the negative log-likelihood of this model fit   
* `AIC` : AIC score of the model  

```{r summary.m4, echo=FALSE, warning=FALSE, message=FALSE}

m4

```

From the intercepts above, State 1 appears to be the high-activity state and State 2 the low-activity state.

Distance has a negative effect on activity in State 1 and a positive one in State 2 (this finding currently has no biological explanation).

Colonies always start their activity in State 1. Once in a state, they rarely switch.

\newpage
We can now plot the relationship between the dependent variable and the covariates. We add the confidence intervals.


### Plots of estimated relationship with covariates

See *Figure 7* in the article.

The most evident finding from these plots is that, once the effect of the covariates is added, activity is higher in State 2 and lower in State 1, with the exception of Colony 4.


```{r extractModel.m4, echo=FALSE, warning=FALSE, message=FALSE}

# Load model fits
ms  <- readRDS("Path/To/Folder/Results/allmROI_S-S2-D.rds")
# The 178th element gives the lowest negative ML

# run numerical maximisation to re-obtain the full object
fss2d <- mle(data=datalist0, parvect = ms[[378]],
             covnm = c("stone_dens","stone_dens2", "distance"), diff=FALSE, hessian = TRUE)

Hinv <- solve(fss2d$H)  # par matrix
```

```{r CIs1.1.m4, echo=FALSE, message=FALSE, warning=FALSE}
################################################################################
# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 1 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1)) # par coordinates
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x.s       <- seq(0,1.24,0.01) # we are u the widest value range across all colonies
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar    <- exp(new_DM %*% post)
est_obspar1.1.s     <- exp(new_DM %*% pwar)

CI_obspar1.1.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar1.1.d     <- exp(new_DM2 %*% pwar)

CI_obspar1.1.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```

```{r CIs1.2.m4, echo=FALSE, warning=FALSE, message=FALSE}

# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 1 # which colony to choose
#################################################

## State 2
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix

# stone dens curve
# New DM
x.s       <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar1.2.s     <- exp(new_DM %*% pwar)

CI_obspar1.2.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar1.2.d     <- exp(new_DM2 %*% pwar)

CI_obspar1.2.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```


```{r CIs2.1.m4, echo=FALSE, warning=FALSE, message=FALSE}
# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 2 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix


# stone dens curve
# New DM
x.s       <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar2.1.s     <- exp(new_DM %*% pwar)

CI_obspar2.1.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar2.1.d     <- exp(new_DM2 %*% pwar)

CI_obspar2.1.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```


```{r CIs2.2.m4, echo=FALSE, warning=FALSE, message=FALSE}
# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 2 # which colony to choose
#################################################

## State 2
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix


# stone dens curve
# New DM
x.s       <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM    <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar2.2.s     <- exp(new_DM %*% pwar)

CI_obspar2.2.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar2.2.d     <- exp(new_DM2 %*% pwar)

CI_obspar2.2.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```


```{r CIs3.1.m4, echo=FALSE, warning=FALSE, message=FALSE}

# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 3 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix


# stone dens curve
# New DM
x.s       <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar3.1.s     <- exp(new_DM %*% pwar)

CI_obspar3.1.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar3.1.d     <- exp(new_DM2 %*% pwar)

CI_obspar3.1.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```

```{r CIs3.2.m4, echo=FALSE, warning=FALSE, message=FALSE}
# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 3 # which colony to choose
#################################################

## State 2
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix

# stone dens curve
# New DM
x.s       <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar3.2.s     <- exp(new_DM %*% pwar)

CI_obspar3.2.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar3.2.d     <- exp(new_DM2 %*% pwar)

CI_obspar3.2.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```


```{r CIs4.1.m4, echo=FALSE, warning=FALSE, message=FALSE}

# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 4 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix


# stone dens curve
# New DM
x.s      <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar4.1.s     <- exp(new_DM %*% pwar)

CI_obspar4.1.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar4.1.d     <- exp(new_DM2 %*% pwar)

CI_obspar4.1.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))

```


```{r CIs4.2.m4, echo=FALSE, warning=FALSE, message=FALSE}

# Get the working parameters
pwar <- pn2pw(int = fss2d$int, xl = fss2d$covL, gsd = fss2d$gsd,
              d = fss2d$delta, gamma = fss2d$gamma, diff = FALSE)


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 4 # which colony to choose
#################################################

## State 2
# Take only the ones that you need
ind_par <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1), (13+h-1))
pwar    <- pwar[ind_par]
Sigma   <- Hinv[ind_par, ind_par]

n_sim   <- 1000
post    <- t(MASS::mvrnorm(n = n_sim, mu = pwar, Sigma = Sigma)) # p x n matrix

# stone dens curve
# New DM
x.s       <- seq(0,1.24,0.01) 
n.s       <- length(x.s)
new_DM  <- cbind(1, x.s, x.s^2,  mean(datalist0[[k]]$distance)) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar         <- exp(new_DM %*% post)
est_obspar4.2.s     <- exp(new_DM %*% pwar)

CI_obspar4.2.s      <- t(apply(post_obspar, 1, quantile, probs = c(0.025,0.975)))

# distance curve
x.d       <- seq(19,46,0.225) 
n.d       <- length(x.d)
new_DM2  <- cbind(1,  mean(datalist0[[k]]$stone_dens), (mean(datalist0[[k]]$stone_dens))^2, x.d) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.d       <- exp(new_DM2 %*% post)
est_obspar4.2.d     <- exp(new_DM2 %*% pwar)

CI_obspar4.2.d      <- t(apply(post_obspar.d, 1, quantile, probs = c(0.025,0.975)))


```

```{r combinedCI.s.m4, message=FALSE, warning=FALSE}
col1 <- 'deepskyblue' 
col2 <- 'darkorange'

## stone density

df1.s <- rbind(data.frame(x = x.s, y = est_obspar1.1.s, lower = CI_obspar1.1.s[,1], upper = CI_obspar1.1.s[,2], state = rep(1, n.s)), data.frame(x = x.s, y = est_obspar1.2.s, lower = CI_obspar1.2.s[,1], upper = CI_obspar1.2.s[,2], state = rep(2, n.s)))
df1.s$state <- as.factor(df1.s$state)

df2.s <- rbind(data.frame(x = x.s, y = est_obspar2.1.s, lower = CI_obspar2.1.s[,1], upper = CI_obspar2.1.s[,2], state = rep(1, n.s)), data.frame(x = x.s, y = est_obspar2.2.s, lower = CI_obspar2.2.s[,1], upper = CI_obspar2.2.s[,2], state = rep(2, n.s)))
df2.s$state <- as.factor(df2.s$state)

df3.s <- rbind(data.frame(x = x.s, y = est_obspar3.1.s, lower = CI_obspar3.1.s[,1], upper = CI_obspar3.1.s[,2], state = rep(1, n.s)), data.frame(x = x.s, y = est_obspar3.2.s, lower = CI_obspar3.2.s[,1], upper = CI_obspar3.2.s[,2], state = rep(2, n.s)))
df3.s$state <- as.factor(df3.s$state)

df4.s <- rbind(data.frame(x = x.s, y = est_obspar4.1.s, lower = CI_obspar4.1.s[,1], upper = CI_obspar4.1.s[,2], state = rep(1, n.s)), data.frame(x = x.s, y = est_obspar4.2.s, lower = CI_obspar4.2.s[,1], upper = CI_obspar4.2.s[,2], state = rep(2, n.s)))
df4.s$state <- as.factor(df4.s$state)

dfList.s <- list()
dfList.s[[1]] <- df1.s
dfList.s[[2]] <- df2.s
dfList.s[[3]] <- df3.s
dfList.s[[4]] <- df4.s

pList.s <- list()

for (c in (1:4)) {
  
  pList.s[[c]] <- ggplot(dfList.s[[c]], aes(x = x, y = y)) +
    geom_line(aes(col = state)) +
    coord_cartesian(ylim = c(0,3), expand = FALSE) +
    geom_ribbon(aes(ymin = lower, ymax = upper, col = state, fill = state), linetype = 3, alpha = 0.1) + # alpha is transparency
    scale_color_manual(values = c(col1, col2)) +
    scale_fill_manual(values = c(col1, col2)) +
    {if (c == 1) xlab("stone density") else xlab("")} +
    {if (c == 1)  ylab("mean deposition rate") else ylab("")} +
    ggtitle(paste0("colony ", as.numeric(c)), subtitle = paste0("distance = ", round(mean(datalist0[[c]]$distance), digits = 2), " mm")) +
    theme_classic() +
    {if (c == 4)
      theme(
        plot.title = element_text(hjust = 0.5, face = 'bold', size = 20), 
        plot.subtitle = element_text(hjust = 0.5, size = 18),
        axis.title.x = element_text(margin = margin(t = 10), size = 18), 
        axis.title.y = element_text(margin = margin(r = 10), size = 18),
        legend.position = c(0.85,0.8),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0), 'cm'))
      else
       theme(
        plot.title = element_text(hjust = 0.5, face = 'bold', size = 20), 
        plot.subtitle = element_text(hjust = 0.5, size = 16), 
        axis.title.x = element_text(margin = margin(t = 10), size = 16), 
        axis.title.y = element_text(margin = margin(r = 10), size = 16),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.position = "None",
        plot.margin = unit(c(0.1, 0.1, 0.1, 0), 'cm')) 
    }
}

#pdf("deposition rate over stone density.pdf", width = 14, height = 4)
g.s <- ggarrange(pList.s[[1]], pList.s[[2]], pList.s[[3]], pList.s[[4]], labels = c("","","",""), ncol = 4)

```

```{r combinedCI.d.m4, message=FALSE, warning=FALSE}
col1 <- 'deepskyblue' 
col2 <- 'darkorange'

## distance

df1.d <- rbind( data.frame(x = x.d, y = est_obspar1.1.d, lower = CI_obspar1.1.d[,1], upper = CI_obspar1.1.d[,2], state = rep(1, n.d)), data.frame(x = x.d, y = est_obspar1.2.d, lower = CI_obspar1.2.d[,1], upper = CI_obspar1.2.d[,2], state = rep(2, n.d)))
df1.d$state <- as.factor(df1.d$state)

df2.d <- rbind(data.frame(x = x.d, y = est_obspar2.1.d, lower = CI_obspar2.1.d[,1], upper = CI_obspar2.1.d[,2], state = rep(1, n.d)), data.frame(x = x.d, y = est_obspar2.2.d, lower = CI_obspar2.2.d[,1], upper = CI_obspar2.2.d[,2], state = rep(2, n.d)))
df2.d$state <- as.factor(df2.d$state)

df3.d <- rbind(data.frame(x = x.d, y = est_obspar3.1.d, lower = CI_obspar3.1.d[,1], upper = CI_obspar3.1.d[,2], state = rep(1, n.d)), data.frame(x = x.d, y = est_obspar3.2.d, lower = CI_obspar3.2.d[,1], upper = CI_obspar3.2.d[,2], state = rep(2, n.d)))
df3.d$state <- as.factor(df3.d$state)

df4.d <- rbind(data.frame(x = x.d, y = est_obspar4.1.d, lower = CI_obspar4.1.d[,1], upper = CI_obspar4.1.d[,2], state = rep(1, n.d)), data.frame(x = x.d, y = est_obspar4.2.d, lower = CI_obspar4.2.d[,1], upper = CI_obspar4.2.d[,2], state = rep(2, n.d)))
df4.d$state <- as.factor(df4.d$state)

dfList.d <- list()
dfList.d [[1]] <- df1.d
dfList.d [[2]] <- df2.d
dfList.d [[3]] <- df3.d
dfList.d [[4]] <- df4.d


pList.d <- list()
for (c in (1:4)) {
  
  pList.d[[c]] <- ggplot(dfList.d[[c]], aes(x = x, y = y)) +
    geom_line(aes(col = state)) +
    coord_cartesian(xlim = c(19,46), ylim = c(0,3), expand = FALSE) +
    geom_ribbon(aes(ymin = lower, ymax = upper, col = state, fill = state), linetype = 3, alpha = 0.1) + # alpha is transparency
    scale_color_manual(values = c(col1, col2)) +
    scale_fill_manual(values = c(col1, col2)) +
    {if( c == 1) xlab("distance") else xlab("")} +
    {if( c == 1) ylab("mean deposition rate") else ylab("")} +
    ggtitle("", 
          subtitle = substitute(paste("stone density =", val, " stones/",mm^2), list(val = round(mean(datalist0[[c]]$stone_dens), digits = 2)))) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, face = 'bold', size = 20), 
      plot.subtitle = element_text(hjust = 0.5, size = 16),
      axis.title.x = element_text(margin = margin(t = 10), size = 16), 
      axis.title.y = element_text(margin = margin(r = 10), size = 16),
      legend.position = "None",
      plot.margin = unit(c(0.1, 0.1, 0.1, 0), 'cm')
      )
  
}

#pdf("deposition rate over distance.pdf", width = 14, height = 4)
g.d <- ggarrange(pList.d[[1]], pList.d[[2]], pList.d[[3]], pList.d[[4]], labels = c("","","",""), ncol = 4)

#pdf("deposition rate over covariates.pdf", width = 14, height = 8)
#ggarrange(g.s, g.d, labels = c("A", "B"), ncol = 1)

```

\newpage
### Gamma distributions by colony
```{r distributions.m4, echo=FALSE, warning=FALSE, message=FALSE}

# calculate shape and scale
# scale = variance/mean
# shape = mean/scale

#pdf("state gamma distributions by colony.pdf", width = 8, height = 7)
#postscript("state gamma distributions by colony.eps", width = 480, height = 400)

par(mfrow= c(2,2), mar = c(5, 4.2, 4, 2))

ylim <- c(0,7.5)
xl <- 1000

# colony 1
mean1.1 <- exp(m4$int[1,1]+m4$covL$stone_dens[1,1]*mean(datalist0[[1]]$stone_dens)+m4$covL$stone_dens2[1,1]*mean(datalist0[[1]]$stone_dens)*mean(datalist0[[1]]$stone_dens)+m4$covL$distance[1,1]*mean(datalist0[[1]]$distance))
scale1.1 <- m4$gsd[1,1]*m4$gsd[1,1]/mean1.1
shape1.1 <- mean1.1/scale1.1
mean1.2 <- exp(m4$int[1,2]+m4$covL$stone_dens[1,2]*mean(datalist0[[1]]$stone_dens)+m4$covL$stone_dens2[1,2]*mean(datalist0[[1]]$stone_dens)*mean(datalist0[[1]]$stone_dens)+m4$covL$distance[1,2]*mean(datalist0[[1]]$distance))
scale1.2 <- m4$gsd[1,2]*m4$gsd[1,2]/mean1.2
shape1.2 <- mean1.2/scale1.2

x <- seq(min(datalist0[[1]]$D), max(datalist0[[1]]$D), length.out = xl)
hist(datalist0[[1]]$D, freq = F, ylim = ylim, xlab = "deposition rate", main = "colony 1", cex.lab = 1.5, cex.main = 2, las = 1)
curve(dgamma(x, shape1.1, scale = scale1.1), add = TRUE, col = 'deepskyblue', lwd = 2, n = xl)
curve(dgamma(x, shape1.2, scale = scale1.2), add = TRUE, col = 'darkorange', lwd = 2, n = xl)
legend('topright', legend = c("state 1", "state 2"), col = c('deepskyblue', 'darkorange'), cex = 1.5, bty = 'n', lty = 1, lwd = 2)

# ggplot(datalist0[[1]], aes(x = D, colour = c("deepskyblue", "darkorange"))) +
#   geom_histogram(colour = 'black', 
#                  fill = 'white') +
#   stat_function(fun = dgamma, args = list(shape = shape1.1, scale = scale1.1), n = xl, col = 'deepskyblue', lwd = 2) + 
#   stat_function(fun = dgamma, args = list(shape = shape1.2, scale = scale1.2), n = xl, col = 'darkorange', lwd = 2) +
#   xlab("deposition rate") +
#   scale_color_manual(name = "", values = )
# 
# ggsave(filename = "state gamma distribution colony 1.eps", width = 8, height = 7, pointsize = 12, dpi = 1000)

# colony 2
mean2.1 <- exp(m4$int[2,1]+m4$covL$stone_dens[1,1]*mean(datalist0[[2]]$stone_dens)+m4$covL$stone_dens2[1,1]*mean(datalist0[[2]]$stone_dens)*mean(datalist0[[2]]$stone_dens)+m4$covL$distance[1,1]*mean(datalist0[[2]]$distance))
scale2.1 <- m4$gsd[2,1]*m4$gsd[2,1]/mean2.1
shape2.1 <- mean2.1/scale2.1
mean2.2 <- exp(m4$int[2,2]+m4$covL$stone_dens[1,2]*mean(datalist0[[2]]$stone_dens)+m4$covL$stone_dens2[1,2]*mean(datalist0[[2]]$stone_dens)*mean(datalist0[[2]]$stone_dens)+m4$covL$distance[1,2]*mean(datalist0[[2]]$distance))
scale2.2 <- m4$gsd[2,2]*m4$gsd[2,2]/mean2.2
shape2.2 <- mean2.2/scale2.2

x <- seq(min(datalist0[[2]]$D), max(datalist0[[2]]$D), length.out = xl)
hist(datalist0[[2]]$D, freq = F, ylim = c(0,7.5), ylab = "", xlab = "", main = "colony 2", cex.main = 2, las = 1)
curve(dgamma(x, shape2.1, scale = scale2.1), add = TRUE, col = 'deepskyblue', lwd = 2, n = xl)
curve(dgamma(x, shape2.2, scale = scale2.2), add = TRUE, col = 'darkorange', lwd = 2, n = xl)

# colony 3
mean3.1 <- exp(m4$int[3,1]+m4$covL$stone_dens[1,1]*mean(datalist0[[3]]$stone_dens)+m4$covL$stone_dens2[1,1]*mean(datalist0[[3]]$stone_dens)*mean(datalist0[[3]]$stone_dens)+m4$covL$distance[1,1]*mean(datalist0[[3]]$distance))
scale3.1 <- m4$gsd[3,1]*m4$gsd[3,1]/mean3.1
shape3.1 <- mean3.1/scale3.1
mean3.2 <- exp(m4$int[3,2]+m4$covL$stone_dens[1,2]*mean(datalist0[[3]]$stone_dens)+m4$covL$stone_dens2[1,2]*mean(datalist0[[3]]$stone_dens)*mean(datalist0[[3]]$stone_dens)+m4$covL$distance[1,2]*mean(datalist0[[3]]$distance))
scale3.2 <- m4$gsd[3,2]*m4$gsd[3,2]/mean3.2
shape3.2 <- mean3.2/scale3.2

x <- seq(min(datalist0[[3]]$D), max(datalist0[[3]]$D), length.out = xl)
hist(datalist0[[3]]$D, freq = F, ylim = ylim, ylab = "", xlab = "", main = "colony 3", cex.main = 2, las = 1)
curve(dgamma(x, shape3.1, scale = scale3.1), add = TRUE, col = 'deepskyblue', lwd = 2, n = xl)
curve(dgamma(x, shape3.2, scale = scale3.2), add = TRUE, col = 'darkorange', lwd = 2, n = xl)

# colony 4
mean4.1 <- exp(m4$int[4,1]+m4$covL$stone_dens[1,1]*mean(datalist0[[4]]$stone_dens)+m4$covL$stone_dens2[1,1]*mean(datalist0[[4]]$stone_dens)*mean(datalist0[[4]]$stone_dens)+m4$covL$distance[1,1]*mean(datalist0[[4]]$distance))
scale4.1 <- m4$gsd[4,1]*m4$gsd[4,1]/mean4.1
shape4.1 <- mean4.1/scale4.1
mean4.2 <- exp(m4$int[4,2]+m4$covL$stone_dens[1,2]*mean(datalist0[[4]]$stone_dens)+m4$covL$stone_dens2[1,2]*mean(datalist0[[4]]$stone_dens)*mean(datalist0[[4]]$stone_dens)+m4$covL$distance[1,2]*mean(datalist0[[4]]$distance))
scale4.2 <- m4$gsd[4,2]*m4$gsd[4,2]/mean4.2
shape4.2 <- mean4.2/scale4.2

x <- seq(min(datalist0[[4]]$D), max(datalist0[[4]]$D), length.out = xl)
hist(datalist0[[4]]$D, freq = F, ylim = ylim, ylab = "", xlab = "", main = "colony 4", cex.main = 2, las = 1)
curve(dgamma(x, shape4.1, scale = scale4.1), add = TRUE, col = 'deepskyblue', lwd = 2, n = xl)
curve(dgamma(x, shape4.2, scale = scale4.2), add = TRUE, col = 'darkorange', lwd = 2, n = xl)

```

\newpage
We now check the estimated state sequence for each colony.

### Estimated state sequence

#### Overall

```{r viterbi.m4, echo=FALSE, warning=FALSE, message=FALSE}

states <- viterbi(m4, datalist0, c("stone_dens", "stone_dens2", "distance"))

#pdf("state sequence by colony.pdf", width = 8.5, height = 7)

par(mfrow = c(2,2))
colscheme <- c(col1, col2)

for (colony in 1:4) {
  n <- nrow(datalist0[[colony]])/3
  Dvect <- c()
  for (t in 1:n) {Dvect <- c(Dvect,mean(datalist0[[colony]][c((t*3):(t*3-2)),"D"]))}
  
  if (colony == 1) {
    plot(Dvect, 
     type = 'h', 
     col = colscheme[states[[colony]]], 
     ylim = c(0, 1.5),
     xlim = c(0, n+1),
     xaxs = 'i',
     yaxs = 'i',
     xaxt = 'n',
     yaxt = 'n',
     ylab = "observed deposition rate", 
     xlab = "time from start of activity (min)", 
     main = paste0("colony ", as.character(colony)),
     frame.plot = FALSE)
   legend('topright',
     legend = c("state 1", "state 2"),
       col = colscheme,
       lty = 1,
       bty = 'n')
  } else {
    plot(Dvect, 
       type = 'h', 
       col = colscheme[states[[colony]]], 
       ylim = c(0, 1.5),
       xlim = c(0, n+1),
       xaxs = 'i',
       yaxs = 'i',
       xaxt = 'n',
       yaxt = 'n',
       ylab = "",
       xlab = "",
       main = paste0("colony ", as.character(colony)),
       frame.plot = FALSE)
  }
  nt <- seq(0,length(states[[colony]])+5, 5)
  axis(1, at = nt, labels = c(nt*15)) # x axis
  axis(2, at = seq(0, 1.5, 0.5), las = 1) # y axis
}

```

\newpage
#### By site - colony 1    
\hfill\break

```{r viterbi_col1.m4, echo=FALSE, warning=FALSE, message=FALSE}

site1.1 <- datalist0[[1]][which(datalist0[[1]]$Site == 1),]
site1.2 <- datalist0[[1]][which(datalist0[[1]]$Site == 2),]
site1.3 <- datalist0[[1]][which(datalist0[[1]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,1.5)
plot(site1.1$D, type = 'h', col = colscheme[states[[1]]], ylim = ylim, ylab = "Observed deposition rate", xlab = "timepoint", main = "Colony 1, Site 1")
plot(site1.2$D, type = 'h', col = colscheme[states[[1]]], ylim = ylim, ylab = "Observed deposition rate", xlab = "timepoint", main = "Colony 1, Site 2")
plot(site1.3$D, type = 'h', col = colscheme[states[[1]]], ylim = ylim, ylab = "Observed deposition rate", xlab = "timepoint", main = "Colony 1, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')


```

\newpage
#### By site - colony 2    
\hfill\break
   
```{r viterbi_col2.m4, echo=FALSE, warning=FALSE, message=FALSE}

site2.1 <- datalist0[[2]][which(datalist0[[2]]$Site == 1),]
site2.2 <- datalist0[[2]][which(datalist0[[2]]$Site == 2),]
site2.3 <- datalist0[[2]][which(datalist0[[2]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,1.5)
plot(site2.1$D, type = 'h', col = colscheme[states[[2]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 2, Site 1")
plot(site2.2$D, type = 'h', col = colscheme[states[[2]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 2, Site 2")
plot(site2.3$D, type = 'h', col = colscheme[states[[2]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 2, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')


```

\newpage
#### By site - colony 3    
\hfill\break
   
```{r viterbi_col3.m4, echo=FALSE, warning=FALSE, message=FALSE}

site3.1 <- datalist0[[3]][which(datalist0[[3]]$Site == 1),]
site3.2 <- datalist0[[3]][which(datalist0[[3]]$Site == 2),]
site3.3 <- datalist0[[3]][which(datalist0[[3]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,1.5)
plot(site3.1$D, type = 'h', col = colscheme[states[[3]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 3, Site 1")
plot(site3.2$D, type = 'h', col = colscheme[states[[3]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 3, Site 2")
plot(site3.3$D, type = 'h', col = colscheme[states[[3]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 3, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')


```

\newpage
#### By site - colony 4    
\hfill\break
   
```{r viterbi_col4.m4, echo=FALSE, warning=FALSE, message=FALSE}

site4.1 <- datalist0[[4]][which(datalist0[[4]]$Site == 1),]
site4.2 <- datalist0[[4]][which(datalist0[[4]]$Site == 2),]
site4.3 <- datalist0[[4]][which(datalist0[[4]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,3.5)
plot(site4.1$D, type = 'h', col = colscheme[states[[4]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 4, Site 1")
plot(site4.2$D, type = 'h', col = colscheme[states[[4]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 4, Site 2")
plot(site4.3$D, type = 'h', col = colscheme[states[[4]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 4, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')

```

\newpage
<!-- ## BEST MODEL: Tot effect of covariate components (no intercept) on activity -->
<!-- \hfill\break -->

<!-- THIS CAN BE IGNORED! -->

<!-- Trying to understand how the covariates affect deposition rate. -->

<!-- ### With distance -->

```{r covOnly.m4, echo=FALSE, warning=FALSE, message=FALSE, fig.show = 'hide', results = FALSE}
sx <- x
ds <- mean(mean(datalist0[[1]]$distance), mean(datalist0[[2]]$distance), mean(datalist0[[3]]$distance), mean(datalist0[[4]]$distance))

out1.ss2d <- c()
out2.ss2d <- c()
for (xi in sx) {
  out1.ss2d <- c(out1.ss2d, m4$covL$stone_dens[1,1]*xi+m4$covL$stone_dens2[1,1]*(xi)^2+m4$covL$distance[1,1]*ds)
  out2.ss2d <- c(out2.ss2d, m4$covL$stone_dens[1,2]*xi+m4$covL$stone_dens2[1,2]*(xi)^2+m4$covL$distance[1,2]*ds)

}


par(mfrow = c(1,2))
plot(x = sx, y = out1.ss2d,
     main = paste0("State 1 \ntot covariate effect across stone dens (no int), \n distance = ", as.character(round(ds, 2))),
     cex.main = 0.8,
     xlab = "stone density",
     ylab = "tot cov effect on mean deposition rate"
)
plot(x = sx, y = out2.ss2d,
     main = paste0("State 2 \ntot covariate effect across stone dens (no int), \n distance = ", as.character(round(ds, 2))),
     cex.main = 0.8,
     xlab = "stone density",
     ylab = "tot cov effect on mean deposition rate"
)




```

<!-- ### Stone density + stone density squared -->

```{r, fig.show = 'hide', results = FALSE}

out1.ss2 <- c()
out2.ss2 <- c()
for (xi in sx) {
  out1.ss2 <- c(out1.ss2, m4$covL$stone_dens[1,1]*xi+m4$covL$stone_dens2[1,1]*(xi)^2)
  out2.ss2 <- c(out2.ss2, m4$covL$stone_dens[1,2]*xi+m4$covL$stone_dens2[1,2]*(xi)^2)

}


par(mfrow = c(1,2))
plot(x = sx, y = out1.ss2,
     main = "State 1 \ntot covariate effect across stone dens (no int)",
     cex.main = 0.8,
     xlab = "stone density",
     ylab = "tot cov effect on mean deposition rate"
)
plot(x = sx, y = out2.ss2,
     main = "State 2 \ntot covariate effect across stone dens (no int)",
     cex.main = 0.8,
     xlab = "stone density",
     ylab = "tot cov effect on mean deposition rate"
)


```

\newpage
Next, we are comparing the values simulated by this best model with our observations.

### Simulations

```{r m4.sim, echo=FALSE, warning=FALSE, message=FALSE}

m4.pred <- HMM.generate_sample(m4, c("stone_dens", "stone_dens2", "distance"), datalist0)

```

#### All simulation plots

```{r plotSim.m4, echo=FALSE, warning=FALSE, message=FALSE}
#pdf("simulated vs observed.pdf", width = 10, height = 5)

layout.matrix <- matrix(c(1,5,2,6,3,7,4,8), nrow = 2, ncol = 4)
layout(mat = layout.matrix, heights = c(1.6,1.4), widths = rep(2.5,4))

#par(mfrow = c(1,4))
ylim = c(0,3.5)

for (colony in 1:4) {
  
  xlim <- c(0, max(datalist0[[colony]]$stone_dens)+0.1)

  if (colony ==1) {
    
    plot(x = datalist0[[colony]]$stone_dens, y = datalist0[[colony]]$D,
       type = 'p',
       pch = 1,
       xlim = xlim,
       ylim = ylim,
       xaxs = 'i',
       yaxs = 'i',
       xaxt = 'n',
       yaxt = 'n',
       main = paste0("colony ", as.character(colony)),
       #xlab = expression(stone~density~(stones/mm^2)),
       xlab = "stone density",
       ylab = "deposition rate",
       frame.plot = FALSE
       )
    legend('topright', legend = c("observed", "simulated"), 
         col = c("black", "red"),
         pch = 16,
         bty = 'n')
    
  } else {
    
    plot(x = datalist0[[colony]]$stone_dens, y = datalist0[[colony]]$D,
       type = 'p',
       pch = 1,
       xlim = xlim,
       ylim = ylim,
       xaxs = 'i',
       yaxs = 'i',
       xaxt = 'n',
       yaxt = 'n',
       main = paste0("colony ", as.character(colony)),
       xlab = "",
       ylab = "",
       frame.plot = FALSE
       )

  }
  lines(x = m4.pred[[colony]]$stone_dens, y = m4.pred[[colony]]$D, type = 'p', pch = 1, col = 'red')
  axis(1, at = c(0, max(datalist0[[colony]]$stone_dens)+0.1), labels = c("",""), lwd.ticks = 0)
  axis(1, at = seq(0, max(datalist0[[colony]]$stone_dens)+0.1, 0.2), lwd = 0, lwd.ticks = 1)
  axis(2, at = ylim, labels = c("",""), lwd.ticks = 0)
  axis(2, at = seq(0,3.5,0.5), lwd = 0, lwd.ticks = 1, las = 1)
}

par(mar = c(5,4,2,2))
for (colony in 1:4) {
  
  #xmin <- min(datalist0[[colony]]$distance)-3
  xmin <- 17
  xmax <- max(datalist0[[colony]]$distance)+3
  xlim <- c(xmin, xmax)

  if (colony ==1) {
    
    plot(x = datalist0[[colony]]$distance, y = datalist0[[colony]]$D,
       type = 'p',
       pch = 1,
       xlim = xlim,
       ylim = ylim,
       xaxs = 'i',
       yaxs = 'i',
       xaxt = 'n',
       yaxt = 'n',
       #main = paste0("colony ", as.character(colony)),
       xlab = "distance",
       ylab = "",
       frame.plot = FALSE
       )

  } else {
    
    plot(x = datalist0[[colony]]$distance, y = datalist0[[colony]]$D,
       type = 'p',
       pch = 1,
       xlim = xlim,
       ylim = ylim,
       xaxs = 'i',
       yaxs = 'i',
       xaxt = 'n',
       yaxt = 'n',
       #main = paste0("colony ", as.character(colony)),
       xlab = "",
       ylab = "",
       frame.plot = FALSE
       )

  }
  lines(x = m4.pred[[colony]]$distance, y = m4.pred[[colony]]$D, type = 'p', pch = 1, col = 'red')
  axis(1, at = c(xmin, xmax), labels = c("",""), lwd.ticks = 0)
  axis(1, at = seq(ceiling(xmin), floor(xmax), 5), lwd = 0, lwd.ticks = 1)
  axis(2, at = ylim, labels = c("",""), lwd.ticks = 0)
  axis(2, at = seq(0,3.5,0.5), lwd = 0, lwd.ticks = 1, las = 1)
  
}

```

\newpage
## SQUARED STONE DENSITY MODEL

Let's now take a look at the second best model, to compare the estimated effect of (squared) stone density - this will add to our confidence in the effect of the square relationship, if the two models are similar.    
The model with the square of stone density and without distance is the second best, although with a large delta AIC: `r m4$AIC - m3$AIC`.

```{r summary.m3, echo=FALSE, warning=FALSE, message=FALSE}

m3

```

### Plots of estimated relationship with covariates
#### Colony 1

```{r extractModel.m3, echo=FALSE, warning=FALSE, message=FALSE}

# Load model fits
ms.3  <- readRDS("Path/To/Folder/Results/allmROI_S-S2.rds")

mllk.vect <- c()
for (m in 1:200) {mllk.vect <- c(mllk.vect, ms.3[[m]]$mllk)}
mi <- which.min(mllk.vect)

# run numerical maximisation to re-obtain the full object
fss2d.m3 <- mle(data=datalist0, parvect = ms.3[[mi+200]],
             covnm = c("stone_dens","stone_dens2"), diff=FALSE, hessian = TRUE)

Hinv.m3 <- solve(fss2d.m3$H)  # par matrix
```

```{r CIs1.1.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 1 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

```{r CIs1.2.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 1 # which colony to choose
#################################################

# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

#### Colony 2

```{r CIs2.1.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 2 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

```{r CIs2.2.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 2 # which colony to choose
#################################################

# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

#### Colony 3

```{r CIs3.1.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 3 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

```{r CIs3.2.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 3 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

#### Colony 4

```{r CIs4.1.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 1 # which state to choose
k <- 4 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

```{r CIs4.2.m3, echo=FALSE, warning=FALSE, message=FALSE}
################################################################################
# Get the working parameters
pwar.m3 <- pn2pw(int = fss2d.m3$int, xl = fss2d.m3$covL, gsd = fss2d.m3$gsd,
              d = fss2d.m3$delta, gamma = fss2d.m3$gamma, diff = FALSE) 


#################################################
#### You change this part
h <- 2 # which state to choose
k <- 4 # which colony to choose
#################################################

## State 1
# Take only the ones that you need
ind_par.m3 <- c((4*(h-1)+k), (9 + h -1), (11 + h - 1)) # par coordinates
pwar.m3    <- pwar.m3[ind_par.m3]
Sigma.m3   <- Hinv.m3[ind_par.m3, ind_par.m3]

n_sim   <- 1000
post.m3    <- t(MASS::mvrnorm(n = n_sim, mu = pwar.m3, Sigma = Sigma.m3)) # p x n matrix   # produces samples from the gamma distribution

## stone density curve
# New DM
x       <- seq(0,1.24,0.01) 
n       <- length(x)
new_DM  <- cbind(1, x, x^2) # r x p matrix
# distance is set to the mean in the colony

# Block diagonal matrix
# new_DM_allpar  <- bdiag(new_DM, new_DM) # r x p*2
post_obspar.m3    <- exp(new_DM %*% post.m3)
est_obspar.m3     <- exp(new_DM %*% pwar.m3)

CI_obspar.m3      <- t(apply(post_obspar.m3, 1, quantile, probs = c(0.025,0.975)))

ylim <- c(0, 3)
plot(x, est_obspar.m3, 
     type="l", 
     main = paste("State ", h, ", Colony ", k),
     cex.main = 1,
     xlab = "stone density", 
     ylab = "mean deposition rate", 
     ylim = ylim, 
     xlim = c(0, 1.29)
     )
segments(x0 = x, y0 = CI_obspar.m3[,1], y1 = CI_obspar.m3[,2])

```

### Estimated state sequence

#### Overall

```{r viterbi.m3, echo=FALSE, warning=FALSE, message=FALSE}

states.m3 <- viterbi(m3, datalist0, c("stone_dens", "stone_dens2"))

par(mfrow = c(2,2))
colscheme <- c("forestgreen", "darkorange")

for (colony in 1:4) {
  n <- nrow(datalist0[[colony]])/3
  Dvect <- c()
  for (t in 1:n) {Dvect <- c(Dvect,mean(datalist0[[colony]][c((t*3):(t*3-2)),"D"]))}
  
  plot(Dvect, 
       type = 'h', 
       col = colscheme[states.m3[[colony]]], 
       ylim = c(0, 1.5), 
       ylab = "observed deposition rate", 
       xlab = "timepoint", 
       main = paste0("Colony ", as.character(colony)))
  legend('topright',
       legend = c("state 1", "state 2"),
       col = colscheme,
       lty = 1,
       bty = 'n')
}


```

\newpage
#### By site - colony 1    
\hfill\break

```{r viterbi_col1.m3, echo=FALSE, warning=FALSE, message=FALSE}

site1.1 <- datalist0[[1]][which(datalist0[[1]]$Site == 1),]
site1.2 <- datalist0[[1]][which(datalist0[[1]]$Site == 2),]
site1.3 <- datalist0[[1]][which(datalist0[[1]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,1.5)
plot(site1.1$D, type = 'h', col = colscheme[states.m3[[1]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 1, Site 1")
plot(site1.2$D, type = 'h', col = colscheme[states.m3[[1]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 1, Site 2")
plot(site1.3$D, type = 'h', col = colscheme[states.m3[[1]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 1, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')


```

\newpage
#### By site - colony 2
\hfill\break

```{r viterbi_col2.m3, echo=FALSE, warning=FALSE, message=FALSE}

site2.1 <- datalist0[[2]][which(datalist0[[2]]$Site == 1),]
site2.2 <- datalist0[[2]][which(datalist0[[2]]$Site == 2),]
site2.3 <- datalist0[[2]][which(datalist0[[2]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,1.5)
plot(site2.1$D, type = 'h', col = colscheme[states.m3[[2]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 2, Site 1")
plot(site2.2$D, type = 'h', col = colscheme[states.m3[[2]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 2, Site 2")
plot(site2.3$D, type = 'h', col = colscheme[states.m3[[2]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 2, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')


```

\newpage
#### By site - colony 3    
\hfill\break
   
```{r viterbi_col3.m3, echo=FALSE, warning=FALSE, message=FALSE}

site3.1 <- datalist0[[3]][which(datalist0[[3]]$Site == 1),]
site3.2 <- datalist0[[3]][which(datalist0[[3]]$Site == 2),]
site3.3 <- datalist0[[3]][which(datalist0[[3]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,1.5)
plot(site3.1$D, type = 'h', col = colscheme[states.m3[[3]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 3, Site 1")
plot(site3.2$D, type = 'h', col = colscheme[states.m3[[3]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 3, Site 2")
plot(site3.3$D, type = 'h', col = colscheme[states.m3[[3]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 3, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')


```

\newpage
#### By site - colony 4    
\hfill\break
   
```{r viterbi_col4.m3, echo=FALSE, warning=FALSE, message=FALSE}

site4.1 <- datalist0[[4]][which(datalist0[[4]]$Site == 1),]
site4.2 <- datalist0[[4]][which(datalist0[[4]]$Site == 2),]
site4.3 <- datalist0[[4]][which(datalist0[[4]]$Site == 3),]

par(mfrow = c(1,3))
ylim <- c(0,3.5)
plot(site4.1$D, type = 'h', col = colscheme[states[[4]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 4, Site 1")
plot(site4.2$D, type = 'h', col = colscheme[states[[4]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 4, Site 2")
plot(site4.3$D, type = 'h', col = colscheme[states[[4]]], ylim = ylim, ylab = "observed deposition rate", xlab = "timepoint", main = "Colony 4, Site 3")
legend('topright', legend = c("state 1", "state 2"), col = colscheme, lty = 1, bty = 'n')

```

\newpage
### Tot effect of covariate components (no intercept) on activity
\hfill\break

```{r m3.sim, echo=FALSE, warning=FALSE, message=FALSE}

m3.pred <- HMM.generate_sample(m3, c("stone_dens", "stone_dens2"), datalist0)

```

```{r plotSimS.m3, echo=FALSE, warning=FALSE, message=FALSE}

par(mfrow = c(2,2))
ylim = c(0,3.5)

for (colony in 1:4) {
  
  plot(x = datalist0[[colony]]$stone_dens, y = datalist0[[colony]]$D,
       type = 'p',
       pch = 1,
       ylim = ylim,
       main = paste0("Colony ", as.character(colony)),
       xlab = "stone density",
       ylab = "deposition rate"
       )
  lines(x = m3.pred[[colony]]$stone_dens, y = m3.pred[[colony]]$D, type = 'p', pch = 1, col = 'red')
  
  
  if (colony == 4) {
   
    legend('topright', legend = c("observed", "simulated"), 
         col = c("black", "red"),
         pch = 16,
         bty = 'n') 
    
  }
  
}

```
